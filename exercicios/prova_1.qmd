---
title: "Prova 1 - Exercícios práticos"
subtitle: "Redes Complexas para Ciência da Computação"
author: "Luben Miguel, Rodrigo Lassance"
format: 
  pdf:
    toc: true
    documentclass: scrartcl
    highlight-style: github
editor: source
lang: pt
---

```{r echo = F}
knitr::opts_chunk$set(warning = FALSE, echo = FALSE, size = "scriptsize")
```

```{r}
#| warning: false
# pacotes sendo usados
library(igraph)
library(tidyverse)
library(Matrix)
library(knitr)
library(scales)
library(GGally)
library(ggcorrplot)
```

# Exercício 1
Para esse exercício utilizamos as redes de conexão entre as fibras do cerebro de ratos [bn-mouse_visual-cortex_2](https://networkrepository.com/bn-mouse-visual-cortex-2.php), rede de co-autoria de artigos da área de redes complexas [ca-netscience](https://networkrepository.com/ca-netscience.php) e a rede de emails mandados entre funcionários da empresa de energia Enron que deixou de existir em 2007 [email-enron-only](https://networkrepository.com/email-enron-only.php).

```{r}
#| warning: false
# todas as redes sao nao direcionadas
# rede dos emails da empresa enron
enron_dados <- readMM("dados/email-enron-only.mtx")

enron_graph <- enron_dados |> 
  graph_from_adjacency_matrix(mode = "undirected") %>%
  set_vertex_attr(name = "name", value = seq_along(V(.)))


# rede do cortex dos ratos
cortex_dados <- read.table("dados/bn-mouse_visual-cortex_2.edges",
                          sep=" ", header = FALSE) |>
  as.matrix()

# removendo nó sem vizinho

cortex_adj <- cortex_dados |> 
  graph_from_edgelist(directed=FALSE) |>
  as_adj()

cortex_adj <- cortex_adj[
  which(colMeans(cortex_adj) != 0), which(colMeans(cortex_adj) != 0)]

cortex_graph <- cortex_adj |>
  graph_from_adjacency_matrix(mode = "undirected")


# rede de coautoria
coauthor_dados <- readMM("dados/ca-netscience.mtx")

coauthor_graph <- coauthor_dados |> graph_from_adjacency_matrix(mode = "undirected")
```
Selecionada essas redes utilizamos como métodos de detecção de comunidades o método de Louven, Girvan-Newman e propagação de rótulos.
```{r}
set.seed(69)
community_detection <- function(igraph_obj){
  # objeto dos clusters
  gn_cluster <- igraph_obj |> cluster_edge_betweenness()
  louvain_cluster <- igraph_obj |> cluster_louvain()
  label_prop <- igraph_obj |> cluster_label_prop()
  return(list("Girvan-Newman" = gn_cluster,
              "Louvain" = louvain_cluster,
              "Label Prop" = label_prop))
}

cortex_comun <- cortex_graph |> community_detection()
coauthor_comun <- coauthor_graph |> community_detection()
enron_comun <- enron_graph |> community_detection()
```

## Item (a)
Selecionamos a rede de coautoria para visualização de suas respectivas comunidades estimadas em cada método como pode ser visualizado pela Figura abaixo:
```{r fig.width = 10, fig.height = 10}
set.seed(666)
lay <- layout_nicely(coauthor_graph)

lay_margin <- par(mar = c(1, 1, 1, 1))
par(mfrow=c(3, 1))

plot(coauthor_comun$`Girvan-Newman`, coauthor_graph,
     layout = lay,
     layout.par = lay_margin,
     vertex.size = 5,
     vertex.label = NA,
     edge.curved = TRUE,
     main = "Girvan-Newman")

plot(coauthor_comun$Louvain, coauthor_graph,
     layout = lay,
     layout.par = lay_margin,
     vertex.size = 5,
     vertex.label = NA,
     edge.curved = TRUE,
     main = "Louvain")

plot(coauthor_comun$`Label Prop`, coauthor_graph,
     layout = lay,
     layout.par = lay_margin,
     vertex.size = 5,
     vertex.label = NA,
     edge.curved = TRUE,
     main = "Propagação Rótulo")

```


## Item (b)
A tabela a seguir sumariza o número de comunidades encontrados para cada rede (nas linhas) por cada método (nas colunas):
```{r}
data.frame("Redes" = c("Rede do cortex dos ratos",
                       "Rede de emails",
                       "Rede de co-autoria"),
           "Girvan-Newman" = c(length(cortex_comun$`Girvan-Newman`),
                               length(enron_comun$`Girvan-Newman`),
                               length(coauthor_comun$`Girvan-Newman`)),
           "Louvain" = c(length(cortex_comun$Louvain),
                         length(enron_comun$Louvain),
                         length(coauthor_comun$Louvain)),
           "Propagação de Rótulo" = c(length(cortex_comun$`Label Prop`),
                                      length(enron_comun$`Label Prop`),
                                      length(coauthor_comun$`Label Prop`))) |>
  knitr::kable(format = "latex",
               booktabs = TRUE,
               col.names = c("Redes",
                             "Girvan-Newman",
                             "Louvain",
                             "Propagação de Rótulo"),
               escape = FALSE,
               caption = "Número de comunidades para cada rede usando cada método") |>
  kableExtra::kable_styling(full_width = FALSE,
                            latex_options = "hold_position")
```
## Item (c)
A seguir, assim como no item (b), construimos uma tabela com os valores calculados de modularidade de cada método (nas colunas) para cada rede (nas linhas).
```{r}
data.frame("Redes" = c("Rede do cortex dos ratos",
                       "Rede de emails",
                       "Rede de co-autoria"),
           "Girvan-Newman" = c(modularity(cortex_comun$`Girvan-Newman`),
                               modularity(enron_comun$`Girvan-Newman`),
                               modularity(coauthor_comun$`Girvan-Newman`)),
           "Louvain" = c(modularity(cortex_comun$Louvain),
                         modularity(enron_comun$Louvain),
                         modularity(coauthor_comun$Louvain)),
           "Propagação de Rótulo" = c(modularity(cortex_comun$`Label Prop`),
                                      modularity(enron_comun$`Label Prop`),
                                      modularity(coauthor_comun$`Label Prop`))) |>
  knitr::kable(format = "latex",
               booktabs = TRUE,
               col.names = c("Redes",
                             "Girvan-Newman",
                             "Louvain",
                             "Propagação de Rótulo"),
               escape = FALSE,
               caption = "Modularidade para cada rede usando cada método") |>
  kableExtra::kable_styling(full_width = FALSE,
                            latex_options = "hold_position")
```
Conforme visto em aula, a modularidade tende a ser maior em redes maiores. Ou seja, não sabemos se a modularidade da rede de co-autoria, com 379 vértices, é maior que a rede de ratos, com 193 vértices, por estar melhor separada ou por simplesmente ser uma rede maior.

## Item (d)
Para cada rede utilizada, podemos calcular a similaridade entre as partições encontradas por cada algoritmo através do NMI. Assim, computando o NMI entre os diferentes métodos de detecção de comunidades obtemos os resultados mostrados pela Tabela abaixo:
```{r}
library(aricode)

compute_nmi <- function(comun_obj){
nmi_gn_louv <- NMI(membership(comun_obj$`Girvan-Newman`) |> as.factor(),
    membership(comun_obj$Louvain) |> as.factor())

nmi_gn_lp <- NMI(membership(comun_obj$`Girvan-Newman`) |> as.factor(),
    membership(comun_obj$`Label Prop`) |> as.factor())

nmi_lp_louv <- NMI(membership(comun_obj$`Label Prop`) |> as.factor(),
    membership(comun_obj$Louvain) |> as.factor())
return(c(nmi_gn_louv, nmi_gn_lp, nmi_lp_louv))
}

data.frame(
  "Comparação" = c("Givarn-Newman vs Louvain",
                    "Girvan-Newman vs Label Prop",
                    "Louvain vs Label Prop"),
  "NMI_ratos" = compute_nmi(cortex_comun),
  "NMI_enron" = compute_nmi(enron_comun),
  "NMI_coauthor" =  compute_nmi(coauthor_comun)) |>
knitr::kable(format = "latex",
               booktabs = TRUE,
             col.names = c("Comparação",
                             "Rede de ratos",
                             "Rede de emails",
                             "Rede de coautoria"),
               escape = FALSE,
               caption = "NMI associado a cada combinação dois a dois dos métodos para cada rede") |>
  kableExtra::kable_styling(full_width = FALSE,
                            latex_options = "hold_position")

```
Nota-se primeiramente que para a rede de emails, o valor do NMI calculado na comparação entre os métodos Girvan-Newman e Louvain versus a propagação de rótulos é razoavelmente baixo. Isso pode se dever ao fato de que no método de propagação de rótulos, o número resultante de comunidades é pequeno comparado aos outros dois métodos. Já, para a rede de co-autoria, esperavamos que o valor do NMI fosse maior nessas mesmas comparações devido à quantidade grande de partições obtidas pela propgação de rótulo, mas não foi isso o observado, vide os valores modestos de NMI sumarizados na tabela.

# Exercício 2
```{r}
# grau hierarquico de segundo grau
h_degree <- function(adj_matrix){
  # matriz de grau 2
  A_2 <- adj_matrix %*% adj_matrix
  
  h_graus <- numeric(nrow(A_2))
  for(i in 1:length(h_graus)){
    h_graus[i] <- which(adj_matrix[i,] == 0 & A_2[i, ] > 0) |>
      length() 
    h_graus[i] <- h_graus[i] - ((A_2[i, i] > 0 )+ 0)
    
  }
  
  return(h_graus)
}

# funcao que monta data frame das medidas
group_medidas <- function(igraph_obj, adj_obj){
  grau_db <- igraph_obj |> 
  degree() |>
  as.data.frame() |>
  rename("grau(1)"= "degree(igraph_obj)") |>
    rownames_to_column(var = "vertices")
  
  grau_2_db <- data.frame( 
    grau_2 = adj_obj |> h_degree()) |>
    rename("grau(2)"= grau_2)
  
  close_db <- igraph_obj |>
  closeness(normalized = TRUE) |>
  as.data.frame() |>
  rename(closeness = "closeness(igraph_obj, normalized = TRUE)") |>
  rownames_to_column(var = "vertices") |>
  select(closeness)
  
  bet_db <- igraph_obj |>
  betweenness(normalized = TRUE) |>
  as.data.frame() |>
  rename(betweenness = "betweenness(igraph_obj, normalized = TRUE)") |>
  rownames_to_column(var = "vertices") |>
  select(betweenness)
  
  # agrupando todos os dados
  all_db <- bind_cols(grau_db, grau_2_db, close_db, bet_db)
  
  return(all_db)
}

# obtendo os data-frames de cada rede
lista_igraph <- list("cortex" = cortex_graph,
                     "enron" = enron_graph,
                     "coautor" = coauthor_graph)

lista_mat <- list("cortex" = cortex_adj,
                     "enron" = enron_dados,
                     "coautor" = coauthor_dados)

medidas_db_lista <- lista_igraph |> map2(.y = lista_mat, function(x, y){
  group_medidas(x, y)
})

# funcao para plotar matriz de correlacao
plot_corr <- function(medidas_db, method = "spearman"){
  medidas_db |>
  select(-vertices) |>
  cor(method = method) |>
ggcorrplot(hc.order = TRUE, type = "lower",
     outline.col = "white", lab = TRUE, legend.title = "Correlation")
}


# funcao para plotar a matriz de grafico de dispersao
plot_pairplot <- function(medidas_db){
  ggpairs(medidas_db, columns = 2:5, 
        mapping = aes(alpha = 0.5),
        diag = list(continuous = wrap("densityDiag", colour = "dodgerblue3")),
        progress= FALSE,
        upper = list(continuous = "blank"),
        lower = list(continuous = wrap("points", colour = "dodgerblue3")))
}
```
## Item (a)
A seguir, podemos visualizar o scatter-plot entre cada par de medida para cada rede a seguir:
-   Rede de conexão de fibras do cortex de ratos
```{r fig.width = 8, fig.height = 6, warning = FALSE}
plot_pairplot(medidas_db_lista$cortex)
```
-   Rede de emails mandados entre funcionários da empresa Enron
```{r fig.width = 8, fig.height = 6, warning = FALSE}
plot_pairplot(medidas_db_lista$enron)
```

-   Rede de co-autoria de artigos
```{r fig.width = 8, fig.height = 6, warning = FALSE}
plot_pairplot(medidas_db_lista$coautor)
```

## Item (b)

-   Rede de conexão de fibras do cortex de ratos
```{r fig.width = 8, fig.height = 6, warning = FALSE}
plot_corr(medidas_db_lista$cortex)
```
-   Rede de emails mandados entre funcionários da empresa Enron
```{r fig.width = 8, fig.height = 6, warning = FALSE}
plot_corr(medidas_db_lista$enron)
```

-   Rede de co-autoria de artigos
```{r fig.width = 8, fig.height = 6, warning = FALSE}
plot_corr(medidas_db_lista$coautor)
```

## Item (c)
Tomando a rede de emails e as comunidades obitdas pelo método de Louvain, podemos realizar um ranqueamento dos vértices para as maiores comunidades. Primeiramente, a tabela abaixo nos dá o tamanho de cada comunidade:
```{r}
enron_comun$Louvain |> 
  sizes() |> 
  as.data.frame()  |>
  knitr::kable(format = "latex",
               booktabs = TRUE,
             col.names = c("Comunidade",
                            "Tamanho"),
               escape = FALSE,
               caption = "Tamanho de cada comunidade") |>
  kableExtra::kable_styling(full_width = FALSE,
                            latex_options = "hold_position")
```
Tomando a comunidade 3, que possui um tamanho grande, podemos tomar o subgrafo correspondente a essa comunidade e computar as medidas de centralidade locais e compará-las as medidas globais:
```{r}
# id do grupo
id_vertices <- enron_comun$Louvain |>
  pluck(3)

# subgrafo daquele grupo
enron_subgraph <- subgraph(enron_graph, id_vertices)
enron_adj <-  enron_subgraph |> as_adj()

# medidas de centralidade do grupo
medidas_subgrafo_3 <- group_medidas(enron_subgraph, enron_adj)

medidas_subgrafo_3 |>
  rename(grau_1 = "grau(1)") |>
  arrange(desc(grau_1)) |>
  rename("grau(1)" = "grau_1") |>
  slice(1:10) |>
  knitr::kable(format = "latex",
               booktabs = TRUE,
               escape = FALSE,
               caption = "Top 10 vértices com maior centralidade local para o subgrafo da comunidade 3") |>
  kableExtra::kable_styling(full_width = FALSE,
                            latex_options = "hold_position")
``` 

```{r}
medidas_db_lista$enron |>
  rename(grau_1 = "grau(1)") |>
  arrange(desc(grau_1)) |>
  rename("grau(1)" = "grau_1") |>
  slice(1:10) |>
  knitr::kable(format = "latex",
               booktabs = TRUE,
               escape = FALSE,
               caption = "Top 10 vértices com maior centralidade global") |>
  kableExtra::kable_styling(full_width = FALSE,
                            latex_options = "hold_position")
```


# Exercício 3


# Exercício 4



